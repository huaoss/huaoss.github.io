(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{292:function(e,n,s){"use strict";s.r(n);var t=s(13),r=Object(t.a)({},(function(){var e=this._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 用 for + slice 根据指定的并发数量来分割数组\nconst group = (list = [], max = 0) => {\n    if (!list.length) {\n        return list\n    }\n    let results = []\n    for (let i = 0, len = list.length; i < len; i += max) {\n        results.push(list.slice(i, i + max))\n    }\n    return results\n}\n// 用 async + await 实现的请求集合封装\n// 通过 for...of 去遍历每一个异步函数，然后用 async + await 确保函数的执行顺序，再用 try...catch 来保证即使 reject 报错也不会导致无法继续执行任务。\nconst requestHandler = async (\n    groupedUrl = [],\n    callback = () => {}\n) => {\n    if (!groupedUrl.length) {\n        callback()\n        return groupedUrl\n    }\n    const newGroupedUrl = groupedUrl.map(fn => fn())\n    const resultsMapper = (results) => results.map(callback)\n    const data = await Promise.allSettled(newGroupedUrl).then(resultsMapper)\n    return data;\n}\n\n// 主函数\nconst sendRequest = async (\n    urls = [],\n    max = 0,\n    callback = () => {}\n) => {\n    if (!urls.length) {\n        return urls\n    }\n    const groupedUrls = group(urls, max)\n    const results = []\n    console.log('start !')\n    for (let groupedUrl of groupedUrls) {\n        try {\n            const result = await requestHandler(groupedUrl, callback)\n            results.push(result)\n            console.log('go')\n        } catch {}\n    }\n    console.log('done !')\n    return results\n}\n\n// 总结：利用了 for + async + await 来限制并发。等每次并发任务结果出来之后再执行下一次的任务。\n\n// 执行以下例子：\nconst p1 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p1'))\nconst p2 = () => Promise.resolve(2)\nconst p3 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p3'))\nconst p4 = () => Promise.resolve(4)\nconst p5 = () => new Promise((resolve, reject) => setTimeout(reject, 2000, 'p5'))\nconst p6 = () => Promise.resolve(6)\nconst p7 = () => new Promise((resolve, reject) => setTimeout(resolve, 1000, 'p7'))\nconst p8 = () => Promise.resolve(8)\nconst p9 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p9'))\nconst p10 = () => Promise.resolve(10)\nconst p11 = () => new Promise((resolve, reject) => setTimeout(resolve, 2000, 'p10'))\nconst p12 = () => Promise.resolve(12)\nconst p13 = () => new Promise((resolve, reject) => setTimeout(reject, 1000, 'p11'))\nconst p14 = () => Promise.resolve(14)\n\nconst ps = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14]\nsendRequest(ps, 3, ({\n    reason,\n    value\n}) => {\n    console.log(reason || value)\n});\n// start!\n//  p1\n//  2\n//  p3\n//  go\n//  4\n//  p5\n//  6\n//  go\n//  p7\n//  8\n//  p9\n//  go\n//  10\n//  p10\n//  12\n//  go\n//  p11\n//  14\n//  go\n// done!\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);