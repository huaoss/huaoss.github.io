(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{349:function(t,a,s){"use strict";s.r(a);var e=s(13),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"微信小程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微信小程序"}},[t._v("#")]),t._v(" 微信小程序")]),t._v(" "),a("h2",{attrs:{id:"一、setdata优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、setdata优化"}},[t._v("#")]),t._v(" 一、setData优化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    // 通过长度获取下一次渲染的索引\n    let index = this.data.listData.length;\n    let newData = {}; //新变更数据\n    Api.getNews().forEach((item) => {\n        newData['listData[' + (index++) + ']'] = item //赋值，索引递增\n    }) \n    this.setData(newData) //增量数据，发送数据到视图层\n}\n\n")])])]),a("h2",{attrs:{id:"二、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、"}},[t._v("#")]),t._v(" 二、")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。vue中有，但是不推荐原生操作dom")])]),t._v(" "),a("li",[a("p",[t._v("小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData()方法！")])]),t._v(" "),a("li",[a("p",[t._v("功能可分为webview和appService两个部分；")]),t._v(" "),a("p",[t._v("webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；")]),t._v(" "),a("p",[t._v("两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。")])])]),t._v(" "),a("p",[t._v("子组件 ———————— created\n子组件 ———————— attached\n页面   ———————— onLoad\n子组件 ———————— pageLifetimes —————— show\n页面   ———————— onShow\n子组件 ———————— ready\n页面   ———————— onReady")]),t._v(" "),a("p",[t._v("子组件 ———————— pageLifetimes —————— hide\n页面   ———————— onHide")]),t._v(" "),a("p",[t._v("子组件 ———————— pageLifetimes —————— show\n页面   ———————— onShow")]),t._v(" "),a("p",[t._v("小程序在挂载、初始化的时候，是从内到外（从组件到page），在卸载的时候也是从内到外的\n页面回退时，可以触发 pageLifetimes 的 show，这个特性可用来更新组件\n用事件触发 Page 的 onShow、onLoad，组件生命周期（lifetimes）、组件中所在页面的生命周期（pageLifetimes）不会被再次调用，所以【Page想通过method调用onShow、onLoad后】 与 【组件内部做生命周期的联动】是不行滴，要老老实实走组件通信了")]),t._v(" "),a("h2",{attrs:{id:"小程序性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序性能优化"}},[t._v("#")]),t._v(" 小程序性能优化")]),t._v(" "),a("p",[t._v("1.页面显示\n组件create->组件attached()->页面onLoad()->组件show()->页面onShow()->组件ready()->页面onReady();\n2.页面隐藏（页面栈不销毁，如navigateTo）;\n在前面的基础上，组件hide()->页面onHide();\n注意页面隐藏时，组件不会进行销毁，所以组件中并不会触发detached（）；")]),t._v(" "),a("h2",{attrs:{id:"为什么不能频繁setdata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能频繁setdata"}},[t._v("#")]),t._v(" 为什么不能频繁setData")]),t._v(" "),a("p",[a("strong",[t._v("setData做的事情：")]),t._v(" 在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。")]),t._v(" "),a("p",[t._v("因此频繁调用，视图会一直更新，阻塞用户交互，引发性能问题。")]),t._v(" "),a("h2",{attrs:{id:"信息流页面上滑触底setdata优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信息流页面上滑触底setdata优化"}},[t._v("#")]),t._v(" 信息流页面上滑触底setData优化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 优化前：每次请求下一页数据，重新赋值整个 list \nthis.setData({\n   list: this.data.list.concat(newList)\n})\n\n// 优化方案：把 list 的数据结构从一维数组改为二维数组：list = [newList, newList]\n// 优化后：每次分页，赋值list的对应子数组\n    let length = this.data.list.length;\n    this.setData({\n       ['list[' + length + ']']: newList\n    });\n")])])]),a("h2",{attrs:{id:"下拉加载优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下拉加载优化"}},[t._v("#")]),t._v(" 下拉加载优化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// 优化前：list头部插入新数组，后重新赋值list\nthis.setData({\n   list: this.data.list.unshift(newList)\n});\n\n// 优化方案： 为下拉加载维护一个单独的二维数组 pullDownList ＋ 使用 wxs 实现反向渲染\nlet length = this.data.pullDownList.length;\nthis.setData({\n   [\'pullDownList[\' + length + \']\']: newList\n});\n\n<wxs module="utils">\n    function reverseArr(arr) {\n       return arr.reverse()\n    }\n    module.exports = {\n       reverseArr: reverseArr\n    }\n</wxs>\n<block wx:for="{{utils.reverseArr(pullDownList)}}" wx:for-item="listItem" wx:key="">\n   <child wx:for="{{listItem}}" wx:key=""></child>\n</block>\n<block wx:for="{{list}}" wx:for-item="listItem" wx:key="">\n <child wx:for="{{listItem}}" wx:key=""></child>\n</block>\n')])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"ps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ps"}},[t._v("#")]),t._v(" PS:")]),t._v(" "),a("h3",{attrs:{id:"_1、this-data与this-setdata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、this-data与this-setdata"}},[t._v("#")]),t._v(" 1、this.data与this.setData")]),t._v(" "),a("p",[t._v("this.setData里面存储的是this.data的副本，而界面是从this.setData里面托管的this.data的副本取数据的。所以更改this.data并不会直接更新界面，因为这个时候的this.setData里面的副本还是没有更新前的。")]),t._v(" "),a("h3",{attrs:{id:"_2、wxs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、wxs"}},[t._v("#")]),t._v(" 2、wxs")]),t._v(" "),a("p",[t._v("WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。")]),t._v(" "),a("p",[t._v("在wxml页面中，只能在插值{{}}中写简单的js表达式，而不能调用方法。wxs可以说就是为了满足能在页面中使用js存在的。")]),t._v(" "),a("p",[t._v("使用："),a("br"),t._v("\n①写好wxs文件 然后导出要使用的方法或变量"),a("br"),t._v("\n②在待使用页面 使用"),a("wxs",{attrs:{src:"/path",module:"tools"}}),t._v("引入"),a("br"),t._v("\n③在插值{{}}中使用tools.method_name(para)")],1),t._v(" "),a("p",[t._v("例如截取字符串")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// string.wxs\n\nfunction my_slice(str,a,b){\n  return str.slice(a,b);\n}\nmodule.exports = {\n  my_slice: my_slice\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<wxs src="../../utils/string.wxs" module="tools" />\n<view>\n    {{tools.my_slice("123456789",0,5)}}\n</view>\n')])])])])}),[],!1,null,null,null);a.default=n.exports}}]);