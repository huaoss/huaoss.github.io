(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{343:function(t,a,e){"use strict";e.r(a);var n=e(13),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"vue-3-x-废弃和修改的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-x-废弃和修改的用法"}},[t._v("#")]),t._v(" Vue 3.x 废弃和修改的用法")]),t._v(" "),a("p",[t._v("一、filters")]),t._v(" "),a("p",[t._v("Filters的功能可以通过方法调用或计算属性轻松复制，因此它主要提供的是语法价值，而不是实际价值。\nFilters需要一个自定义的小语法，然而这打破表达式只是JavaScript的假设——这增加了学习和实现的成本。事实上，它与JavaScript自己的位或运算符(|)相冲突，并使表达式解析更加复杂。\nFilters还会在模板IDE支持中增加额外的复杂性(同样因为它们不是真正的JavaScript)。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<li>运输状态:{{ item.expressState | showState }}</li>\n\n<li>运输状态:{{ computedText(item.expressState) }}</li>\n\nexport default {\n  // data ...... 篇幅有限直接省略掉\n  computed: {\n    computedText() {\n      // 计算属性要return一个函数接收参数\n      return function (state) {\n        switch (state) {\n          case "1":\n            return "待发货";\n            break;\n          case "2":\n            return "已发货";\n            break;\n          case "3":\n            return "运输中";\n            break;\n          case "4":\n            return "派件中";\n            break;\n          case "5":\n            return "已收货";\n            break;\n          default:\n            return "快递信息丢失";\n            break;\n        }\n      };\n    },\n  },\n};\n\nexport default {\n  // data ...... 篇幅有限直接省略掉\n  computed: {\n    computedText() {\n      // 计算属性要return一个函数接收参数\n      return function (state) {\n        switch (state) {\n          case "1":\n            return "待发货";\n            break;\n          case "2":\n            return "已发货";\n            break;\n          case "3":\n            return "运输中";\n            break;\n          case "4":\n            return "派件中";\n            break;\n          case "5":\n            return "已收货";\n            break;\n          default:\n            return "快递信息丢失";\n            break;\n        }\n      };\n    },\n  },\n};\n')])])]),a("p",[t._v("二、"),a("code",[t._v("$on")]),t._v(","),a("code",[t._v("$off")]),t._v("和"),a("code",[t._v("$once")])]),t._v(" "),a("h2",{attrs:{id:"js-运行机制➡️nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-运行机制➡️nexttick"}},[t._v("#")]),t._v(" JS 运行机制➡️nextTick")]),t._v(" "),a("p",[t._v("JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：")]),t._v(" "),a("ul",[a("li",[t._v("所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。")]),t._v(" "),a("li",[t._v('主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。')]),t._v(" "),a("li",[t._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。')])]),t._v(" "),a("p",[t._v("主线程不断重复上面的第三步。")]),t._v(" "),a("p",[t._v("2.1 macro task")]),t._v(" "),a("p",[t._v("宏任务，称为task")]),t._v(" "),a("p",[t._v("macro task作用是为了让浏览器能够从内部获取javascript / dom的内容并确保执行栈能够顺序进行。")]),t._v(" "),a("p",[t._v("macro task调度是随处可见的，例如解析HTML，获得鼠标点击的事件回调等等。")]),t._v(" "),a("p",[t._v("2.2 micro task")]),t._v(" "),a("p",[t._v("微任务，也称job")]),t._v(" "),a("p",[t._v("micro task通常用于在当前正在执行的脚本之后直接发生的事情，比如对一系列的行为做出反应，或者做出一些异步的任务，而不需要新建一个全新的task。")]),t._v(" "),a("p",[t._v("只要执行栈没有其他javascript在执行，在每个task结束时，micro task队列就会在回调后处理。")]),t._v(" "),a("p",[t._v("在micro task期间排队的任何其他micro task将被添加到这个队列的末尾并进行处理。")]),t._v(" "),a("p",[t._v("在浏览器环境中，")]),t._v(" "),a("p",[t._v("常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；")]),t._v(" "),a("p",[t._v("常见的 micro task 有 MutationObsever 和 Promise.then。")]),t._v(" "),a("p",[t._v("vue用异步队列的方式来控制DOM更新和nextTick回调先后执行")]),t._v(" "),a("p",[t._v("microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕")]),t._v(" "),a("p",[t._v("因为兼容性问题，vue不得不做了microtask向macrotask的降级方案")]),t._v(" "),a("h2",{attrs:{id:"props"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[t._v("#")]),t._v(" props")]),t._v(" "),a("p",[t._v("-------让组件接收外部传来的数据")]),t._v(" "),a("p",[t._v("接收数据三种方式：")]),t._v(" "),a("p",[t._v("（1）只接收值：props: ['name','age','sex']")]),t._v(" "),a("p",[t._v('（2）接收并限制类型：props: { "name":Number }')]),t._v(" "),a("p",[t._v("（3）限制类型、限制必要性指定默认值：")]),t._v(" "),a("p",[t._v("注意：props是只读的，vue底层会检测你对props的修改，如果进行了修改，控制台会报错，必须修改，就复制一份到data中，通过data去修改数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/25078225-10806c40c1edb333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/817/format/webp",alt:"img"}})]),t._v(" "),a("h2",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),a("p",[t._v("watch 最初绑定时不会执行，只有数据改变才会执行监听")]),t._v(" "),a("p",[t._v("handler(newVal, oldVal)")]),t._v(" "),a("p",[t._v("immediate:true 会在watch里声明监听对象后立即handler方法，所以可以监听到第一次的值")]),t._v(" "),a("p",[t._v("deep深度监听，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler。")]),t._v(" "),a("p",[t._v("优化为字符串监听：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("watch: {\n  'obj.a': {\n    handler(newName, oldName) {\n      console.log('obj.a changed');\n    },\n    immediate: true,\n    // deep: true\n  }\n} \n\n")])])]),a("p",[t._v("这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数")]),t._v(" "),a("p",[t._v("注销watch:\n为什么要注销 watch？因为我们的组件是经常要被销毁的，比如我们跳一个路由，从一个页面跳到另外一个页面，那么原来的页面的 watch 其实就没用了，这时候我们应该注销掉原来页面的 watch 的，不然的话可能会导致内置溢出。好在我们平时 watch 都是写在组件的选项中的，他会随着组件的销毁而销毁。")]),t._v(" "),a("p",[t._v("但是，如果我们使用下面这样的方式写 watch，那么就要手动注销了，这种注销其实也很简单")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\nconst unWatch = app.$watch('text', (newVal, oldVal) => {\n  console.log(`${newVal} : ${oldVal}`);\n})\n \nunWatch(); // 手动注销watch\n\n")])])]),a("h2",{attrs:{id:"watcheffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect"}},[t._v("#")]),t._v(" watchEffect")])])}),[],!1,null,null,null);a.default=r.exports}}]);