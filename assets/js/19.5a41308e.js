(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{289:function(v,_,e){"use strict";e.r(_);var p=e(13),n=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("1、什么是设计模式？")]),v._v(" "),_("p",[v._v("设计模式是一套反复使用的并且经过分类编目的代码设计经验总结。")]),v._v(" "),_("p",[v._v("2、设计模式有哪些？")]),v._v(" "),_("p",[v._v("GOF提出的23种设计模式，分为三大类。")]),v._v(" "),_("p",[v._v("创建型模式，共5种，分别是工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。")]),v._v(" "),_("p",[v._v("结构型模式，共7种，分别是适配器模式、装饰器模式、代理模式、外观模式桥接模式、组合模式、享元模式。")]),v._v(" "),_("p",[v._v("行为型模式，共11种，分别是策略模式、模板方法模式、观察者模式、选代子模式、責任链模式、命令模式、备忘录模弌、状态模式、访问者模式、中介者模式、解释器模式。")]),v._v(" "),_("p",[v._v("在前端开发中，有些特定的模式不太适用。")]),v._v(" "),_("p",[v._v("当然，有些适用于前端的模式并未包含在这23种设计模式中，如委托模式、节流模式等。")]),v._v(" "),_("p",[v._v("3、你用过哪些设计模式？")]),v._v(" "),_("p",[v._v("工厂模式。")]),v._v(" "),_("p",[v._v("它的优点是可以使用工厂方法而不是new关键字消除对象间的耦合。同时，将所有实例化的代码封装在一起，实现代码重复。工厂模式解决了重复创建对象的问题。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("function factory(name, age){\nvar user= new Object();\nuser.name= name;\nuser age= age；\nuser. getIntro= function(){\nreturn this.name+'\\' s age is ' +this.age；\n}\nreturn user ;\nvar xm= factory（ 'xiao ming',20）; \nconsole. log(xm. getIntro() )  \n// xiao ming's age is 20\n")])])]),_("p",[v._v("4、工厂模式的概念是什么？")]),v._v(" "),_("p",[v._v("其概念如下：")]),v._v(" "),_("p",[v._v("工厂模式需要3个基本步骤，原料投入、加工过程以及成品出厂。")]),v._v(" "),_("p",[v._v("5、工厂模式的缺陷是什么？")]),v._v(" "),_("p",[v._v("缺陷如下")]),v._v(" "),_("p",[v._v("（1）没有使用new关键字，在创建对象的过程中，看不到构造函数实例化的过程。")]),v._v(" "),_("p",[v._v("（2）每个实例化的对象都创建相应的变量和函数，因此需要更多的空间进行属性和方法的存储，从而降低了性能，造成资源的浪费。")]),v._v(" "),_("p",[v._v("6、说说你对MC架构和MwWM架构的理解。")]),v._v(" "),_("p",[v._v("在经典的MVC架构中，包含3个部分，即模型( Model）、视图(view)和控制器(Controller)。控制器可以访问视图，让其更新。控制器可以访问模型，更新数据。视图可以访问模型，获取数据渲染页面。")]),v._v(" "),_("p",[v._v("在MwVM架构中，包含3个部分，即模型( Model)、视图(View)和视图模型(View Model)。视图模型负责视图与模型之间的信息转换，通过欻据双向绑定使视图与模型之间的数据得以传递。")]),v._v(" "),_("p",[v._v("例如代表性的框架 Angular，它通过数据绑定，将模型中的数据映射到视图中，通过事件监听器（ event listener），将视图改变的数据存储在模型内")]),v._v(" "),_("p",[v._v("7、什么是事件代理？")]),v._v(" "),_("p",[v._v("事件代理（ Event Delegation）又称为事件委托，是 JavaScript中常用的绑定事件的方式。")]),v._v(" "),_("p",[v._v("顾名思义，“事件代理”就是把原本需要绑定到子元素的事件委托给父元素，让父元素承担事件监听的工作。")]),v._v(" "),_("p",[v._v("事件代理的原理是DOM元素的事件冒泡。")]),v._v(" "),_("p",[v._v("使用事件代理的好处有很多，如减少事件数量，预测未来元素，避免内存外泄等，有利于提高性能。")]),v._v(" "),_("p",[v._v("8、请说说工厂模式的优缺点。")]),v._v(" "),_("p",[v._v("优点如下。")]),v._v(" "),_("p",[v._v("（1）一个调用者想创建一个对象，只要知道它的名称即可。")]),v._v(" "),_("p",[v._v("（2）扩展性高，如果想增加一个产品，只要扩展一个工厂类即可。")]),v._v(" "),_("p",[v._v("（3）屏蔽产品的具体实现，调用者只需关心产品的接口。")]),v._v(" "),_("p",[v._v("缺点如下。")]),v._v(" "),_("p",[v._v("每次增加一个产品时，都需要増加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。")]),v._v(" "),_("p",[v._v("16、你在开发中都用到了哪些设计模式？它们的作用分别是什么？")]),v._v(" "),_("p",[v._v("毎个模式都描述了一个在开发环境中不断岀现的问题，然后描述了该问题的解决方案。用这种方式，可以无限次地使用那些已有的解决方案，无须再做重复、相同的工作。")]),v._v(" "),_("p",[v._v("开发中常用到的模式如下。")]),v._v(" "),_("p",[v._v("singleton：单例模式，用来减少重复创建对象。")]),v._v(" "),_("p",[v._v("factory：工厂模式，用来解耦。")]),v._v(" "),_("p",[v._v("iterator：迭代器模式，用来遍历对象。")]),v._v(" "),_("p",[v._v("observer：观察者模式，用来收发消息。")]),v._v(" "),_("p",[v._v("templete：模板模式，用来避免执行相同的操作。")]),v._v(" "),_("p",[v._v("strategy：策略模式，用来定义算法等。")])])}),[],!1,null,null,null);_.default=n.exports}}]);