(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{312:function(n,t,e){"use strict";e.r(t);var s=e(13),a=Object(s.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("1.严格模式对 JavaScript 的语法和行为，都做了一些改变。\n严格模式下，变量必须先声明再使用，严禁删除已经声明变量。\n严格模式下，预编译时 this 为 undefined。\n严格模式下，不支持arguments、caller、callee、with。\n严格模式下，在函数内部对修改参数不会反映到 arguments 中，淘汰了 arguments.callee 和 arguments.caller， 抛弃 with 语句。\n严格模式下，不可在 if 内部声明函数\n严格模式下，拒绝重复的属性和参数。\n严格模式下，局部的this必须被赋值、赋值什么就是什么。\n\n2. 严格模式下 this 指向问题\n① 以前在全局作用域函数中的 this 指向 window 对象。\n\n② 严格模式下全局作用域中函数中的 this 是 undefined。\n\n③ 以前构造函数不加 new 也可以调用，当普通函数，this 指向全局对象。\n\n④ 严格模式下，如果构造函数不加 new 调用， this 指向的是 undefined ，如果给他赋值则会报错 。\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);