(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{284:function(e,t,n){"use strict";n.r(t);var a=n(13),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"fetch和ajax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch和ajax"}},[e._v("#")]),e._v(" Fetch和Ajax")]),e._v(" "),t("h3",{attrs:{id:"一、ajax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、ajax"}},[e._v("#")]),e._v(" 一、Ajax")]),e._v(" "),t("p",[e._v("Ajax的本质是使用XMLHttpRequest对象来请求数据：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function ajax(url, fnSucc, fnFaild)\n{\n    //1.创建Ajax对象\n    if(window.XMLHttpRequest){\n       var oAjax=new XMLHttpRequest();\n    }else{\n       var oAjax=new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    \n    //2.连接服务器（打开和服务器的连接）\n    oAjax.open('GET', url, true);\n    \n    //3.发送\n    oAjax.send();\n    \n    //4.接收\n    oAjax.onreadystatechange=function (){\n       if(oAjax.readyState==4){\n           if(oAjax.status==200){\n              //alert('成功了：'+oAjax.responseText);\n              fnSucc(oAjax.responseText);\n           }else{\n              //alert('失败了');\n              if(fnFaild){\n                  fnFaild();\n              }\n           }\n        }\n    };\n}\n")])])]),t("h3",{attrs:{id:"二、fetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、fetch"}},[e._v("#")]),e._v(" 二、fetch")]),e._v(" "),t("p",[e._v("fetch 是全局量 window 的一个方法，它的主要特点有：")]),e._v(" "),t("p",[e._v("1、第一个参数是URL:")]),e._v(" "),t("p",[e._v("2、第二个是可选参数，可以控制不同配置的 init 对象")]),e._v(" "),t("p",[e._v("3、使用了 JavaScript Promises 来处理结果/回调:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 链式处理,将异步变为类似单线程的写法: 高级用法.\nfetch('/some/url').then(function(response) {\n    return . //... 执行成功, 第1步...\n}).then(function(returnedValue) {\n    // ... 执行成功, 第2步...\n}).catch(function(err) {\n    // 中途任何地方出错...在此处理 :( \n});\n")])])]),t("h3",{attrs:{id:"三、fetch规范与jquery-ajax-主要有两种方式的不同-牢记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、fetch规范与jquery-ajax-主要有两种方式的不同-牢记"}},[e._v("#")]),e._v(" 三、fetch规范与jQuery.ajax()主要有两种方式的不同，牢记：")]),e._v(" "),t("p",[e._v("1、从 fetch()返回的 Promise 将"),t("b",[e._v("不会拒绝HTTP错误状态")]),e._v(", 即使响应是一个 HTTP 404 或 500。相反，它会正常解决 (其中ok状态设置为false), 并且仅在网络故障时或任何阻止请求完成时，它才会拒绝。")]),e._v(" "),t("p",[e._v("可以做简单的封装")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function checkStatus(response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response\n  } else {\n    var error = new Error(response.statusText)\n    error.response = response\n    throw error\n  }\n}\n\nfunction parseJSON(response) {\n  return response.json()\n}\n\nfetch('/users')\n  .then(checkStatus)\n  .then(parseJSON)\n  .then(function(data) {\n    console.log('request succeeded with JSON response', data)\n  }).catch(function(error) {\n    console.log('request failed', error)\n  })\n")])])]),t("p",[e._v("2、默认情况下, fetch在服务端不会发送或接收任何 cookies, 如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送 cookies，必须发送凭据头).\n这一点也可以做一些处理：")]),e._v(" "),t("p",[e._v("如果想要在同域中自动发送cookie,加上 credentials 的 same-origin 选项")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fetch(url, {\n  credentials: ’same-origin'\n})\n")])])]),t("p",[e._v("same-origin值使得fetch处理Cookie与XMLHttpRequest类似。 否则，Cookie将不会被发送，导致这些请求不保留认证会话。")]),e._v(" "),t("p",[e._v("对于CORS请求，使用include值允许将凭据发送到其他域：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fetch(url, {\n  credentials: 'include'\n})\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);